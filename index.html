<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Bridge Incidents — CSV (coordinates (lat, lon))</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- MarkerCluster (optional) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <!-- PapaParse for CSV -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    html, body, #map { height: 100%; margin: 0; }
    .topbar {
      position: absolute; z-index: 1000; top: 10px; left: 10px;
      background: rgba(255,255,255,0.95); padding: 8px 10px; border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.15);
      font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display: flex; gap: 8px; align-items: center;
    }
    .legend {
      background: white; padding: 10px 10px 6px; line-height: 1.2;
      border-radius: 8px; box-shadow: 0 1px 6px rgba(0,0,0,0.15);
      font: 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .legend .row { display: flex; align-items: center; margin-bottom: 6px; }
    .legend .swatch { width: 14px; height: 14px; border-radius: 50%;
      margin-right: 8px; border: 1px solid rgba(0,0,0,0.25); box-sizing: border-box; }
    .status {
      position: absolute; left: 10px; bottom: 10px; background: rgba(255,255,255,0.9);
      padding: 6px 8px; border-radius: 6px; font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      box-shadow: 0 1px 4px rgba(0,0,0,0.15); max-width: 60vw; overflow: auto; max-height: 30vh; white-space: pre-wrap;
    }
    select { padding: 4px 6px; }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="topbar">
    <label for="typeFilter"><strong>Incident type:</strong></label>
    <select id="typeFilter"><option value="__ALL__">All types</option></select>
  </div>

  <pre class="status" id="status">Loading…</pre>

  <script>
    const map = L.map('map', { preferCanvas: true }).setView([31, -99], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const status = document.getElementById('status');
    const typeFilter = document.getElementById('typeFilter');

    // CONFIG: change if your CSV uses a different column for incident type
    const INCIDENT_KEY = 'Incident Type';

    // Helpers
    function sanitizeText(txt) {
      return txt.replace(/\bNaN\b/g, '')
                .replace(/\b-Infinity\b/g, '')
                .replace(/\bInfinity\b/g, '');
    }
    function keyLookup(obj, patterns) {
      const keys = Object.keys(obj || {});
      const found = keys.find(k => patterns.some(rx => rx.test(k)));
      return found || null;
    }
    function looksSwapped(lon, lat) {
      // lon looks like a latitude and lat looks like a longitude
      return Math.abs(lon) <= 90 && Math.abs(lat) > 90 && Math.abs(lat) <= 180;
    }
    function normalizeType(v) {
      if (v == null) return null;
      v = String(v).toLowerCase().replace(/[_-]+/g, ' ').replace(/\s+/g, ' ').trim();
      const dict = {
        'flooding': 'flood',
        'floods': 'flood',
        'fires': 'fire',
        'collisions': 'collision',
        'overloaded truck': 'vehicle overload',
        'truck overload': 'vehicle overload',
        'vehicle overloads': 'vehicle overload'
      };
      if (dict[v]) return dict[v];
      if (/ies$/.test(v)) v = v.replace(/ies$/, 'y');
      else if (/(ses|xes|zes|ches|shes)$/.test(v)) v = v.replace(/es$/, '');
      else if (v.endsWith('s') && !v.endsWith('ss')) v = v.slice(0, -1);
      return v;
    }
    function titleCase(s) {
      return String(s).replace(/\w\S*/g, t => t[0].toUpperCase() + t.slice(1).toLowerCase());
    }
    function makePopup(props) {
      if (!props) return '';
      const rows = [];
      const isUrl = v => typeof v === 'string' && /^https?:\/\//i.test(v);
      const domainText = url => { try { return new URL(url).hostname.replace(/^www\./, ''); } catch { return url; } };
      for (const [k, rawV] of Object.entries(props)) {
        if (rawV === null || rawV === undefined) continue;
        let v = String(rawV).trim();
        if (!v || v.toLowerCase() === 'null') continue;
        if (isUrl(v)) v = `<a href="${rawV}" target="_blank" rel="noopener">${domainText(rawV)}</a>`;
        rows.push(`<tr><th style="text-align:left; padding-right:8px;">${k}</th><td>${v}</td></tr>`);
      }
      return `<div style="font:13px/1.3 system-ui, Segoe UI, Roboto, Arial;"><table>${rows.join('')}</table></div>`;
    }

    const palette = ["#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00","#a65628","#f781bf","#999999",
                     "#66c2a5","#fc8d62","#8da0cb","#e78ac3","#a6d854","#ffd92f","#e5c494","#b3b3b3"];
    function colorMapFor(types) {
      const m = {};
      types.forEach((t,i) => m[t] = palette[i % palette.length]);
      return m;
    }

    // Parse a single "coordinates (lat, lon)" value into {lat, lon}
    function parseCoordsField(val) {
      if (val == null) return null;
      const s = String(val).trim();
      // Extract first two numbers (handles "29.76, -95.36", "(29.76, -95.36)", "[29.76, -95.36]", "POINT(-95.36 29.76)" etc.)
      const m = s.match(/-?\d+(?:\.\d+)?/g);
      if (!m || m.length < 2) return null;

      let lat = parseFloat(m[0]);
      let lon = parseFloat(m[1]);

      // Handle WKT-like "POINT(lon lat)" if exported that way
      if (Math.abs(lat) > 90 && Math.abs(lon) <= 90) {
        const tmp = lat; lat = lon; lon = tmp;
      }
      if (!isFinite(lat) || !isFinite(lon)) return null;
      return { lat, lon };
    }

    // Load CSV -> rows -> features
    fetch('Bridge_incident1.csv', { cache: 'no-store' })
      .then(r => r.text())
      .then(txt => {
        const csvText = sanitizeText(txt);
        const parsed = Papa.parse(csvText, { header: true, dynamicTyping: true, skipEmptyLines: true });
        const rows = parsed.data;

        if (!rows.length) throw new Error('CSV seems empty.');

        // Detect coordinate columns/field
        const sample = rows[0] || {};
        const latKey   = keyLookup(sample, [/^lat(i(tude)?)?$/i]);
        const lonKey   = keyLookup(sample, [/^(lon(g(itude)?)?|lng)$/i]);
        const coordKey = keyLookup(sample, [/^coordinates?\s*\(\s*lat\s*,\s*lon\s*\)$/i]); // "coordinates (lat, lon)"

        if (!((latKey && lonKey) || coordKey)) {
          throw new Error('Could not find latitude/longitude columns or a "coordinates (lat, lon)" column.');
        }

        const features = [];
        for (const r of rows) {
          let lat, lon;

          if (coordKey) {
            const pair = parseCoordsField(r[coordKey]);
            if (!pair) continue;
            ({ lat, lon } = pair); // (lat, lon)
          } else {
            lat = parseFloat(r[latKey]);
            lon = parseFloat(r[lonKey]);
          }

          if (!isFinite(lat) || !isFinite(lon)) continue;

          // Safety swap if someone mixed the order
          if (looksSwapped(lon, lat)) { const tmp = lat; lat = lon; lon = tmp; }

          features.push({
            type: "Feature",
            properties: r,
            geometry: { type: "Point", coordinates: [lon, lat] } // GeoJSON order
          });
        }

        if (!features.length) throw new Error('No valid coordinates parsed from CSV.');

        // Type normalization & palette
        const typeLabelMap = new Map();
        for (const f of features) {
          const norm = normalizeType(f.properties?.[INCIDENT_KEY]);
          if (norm != null && !typeLabelMap.has(norm)) typeLabelMap.set(norm, titleCase(norm));
        }
        const typeValues = Array.from(typeLabelMap.keys()).sort();
        const colors = colorMapFor(typeValues);

        // Populate filter UI
        for (const norm of typeValues) {
          const opt = document.createElement('option');
          opt.value = norm; opt.textContent = typeLabelMap.get(norm);
          typeFilter.appendChild(opt);
        }

        // Build layers + clusters (circle dots)
        const groupsByType = {};
        typeValues.forEach(norm => groupsByType[norm] = L.layerGroup());
        let allCluster = null;
        const cluster = L.markerClusterGroup({ spiderfyOnMaxZoom:true, showCoverageOnHover:false, maxClusterRadius:50 });

        for (const f of features) {
          const tNorm = normalizeType(f.properties?.[INCIDENT_KEY]);
          if (tNorm == null) continue;
          const [lon, lat] = f.geometry.coordinates;
          const m = L.circleMarker([lat, lon], {
            radius: 6,
            fillColor: colors[tNorm] || '#666',
            color: '#333',
            weight: 1,
            opacity: 1,
            fillOpacity: 0.9
          }).bindPopup(makePopup(f.properties));
          groupsByType[tNorm].addLayer(m);
          cluster.addLayer(m);
        }

        cluster.addTo(map);
        allCluster = cluster;

        const b = cluster.getBounds();
        if (b.isValid()) map.fitBounds(b.pad(0.1));

        // Legend
        const legend = L.control({ position:'topright' });
        legend.onAdd = function() {
          const div = L.DomUtil.create('div','legend');
          const h = document.createElement('div'); h.textContent = 'Incident Type';
          h.style.fontWeight='600'; h.style.marginBottom='6px';
          div.appendChild(h);
          for (const norm of typeValues) {
            const row = document.createElement('div'); row.className='row';
            const sw = document.createElement('span'); sw.className='swatch'; sw.style.background = colors[norm];
            const lab = document.createElement('span'); lab.textContent = typeLabelMap.get(norm);
            row.appendChild(sw); row.appendChild(lab); div.appendChild(row);
          }
          return div;
        };
        legend.addTo(map);

        status.textContent = `Plotted ${features.length} points. Types: ${typeValues.length}`;

        // Filtering
        typeFilter.addEventListener('change', () => {
          if (allCluster) map.removeLayer(allCluster);
          const newCluster = L.markerClusterGroup({ spiderfyOnMaxZoom:true, showCoverageOnHover:false, maxClusterRadius:50 });
          if (typeFilter.value === '__ALL__') {
            Object.values(groupsByType).forEach(g => g.eachLayer(m => newCluster.addLayer(m)));
          } else {
            groupsByType[typeFilter.value].eachLayer(m => newCluster.addLayer(m));
          }
          newCluster.addTo(map);
          const bb = newCluster.getBounds();
          if (bb.isValid()) map.fitBounds(bb.pad(0.1));
          const label = (typeFilter.value === '__ALL__') ? 'ALL types' : `"${typeLabelMap.get(typeFilter.value)}"`;
          status.textContent = `Showing ${label}. Points: ${newCluster.getLayers().length}`;
          allCluster = newCluster;
        });
      })
      .catch(err => { console.error(err); status.textContent = `Error: ${err.message}`; });
  </script>
</body>
</html>
