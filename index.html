<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Bridge Incidents</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- SheetJS for Excel -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    html, body, #map { height: 100%; margin: 0; }
    .topbar {
      position: absolute; z-index: 1000; top: 10px; left: 10px;
      background: rgba(255,255,255,0.95); padding: 8px 10px; border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.15);
      font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display: flex; gap: 8px; align-items: center;
    }
    .legend {
      background: white; padding: 10px 10px 6px; line-height: 1.2;
      border-radius: 8px; box-shadow: 0 1px 6px rgba(0,0,0,0.15);
      font: 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .legend .row { display: flex; align-items: center; margin-bottom: 6px; }
    .legend .swatch { width: 14px; height: 14px; border-radius: 50%;
      margin-right: 8px; border: 1px solid rgba(0,0,0,0.25); box-sizing: border-box; }
    .status {
      position: absolute; left: 10px; bottom: 10px; background: rgba(255,255,255,0.9);
      padding: 6px 8px; border-radius: 6px; font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      box-shadow: 0 1px 4px rgba(0,0,0,0.15); max-width: 60vw; overflow: auto; max-height: 30vh; white-space: pre-wrap;
    }
    select, button { padding: 4px 6px; }
    .spacer { width: 10px; }
  </style>
</head>
<body>
  <div id="map"></div>

  <!--
    HOW TO USE (choose ONE of the two approaches below):
    A) Load from a URL: set XLSX_URL to your .xlsx path (must be same-origin or CORS-enabled)
    B) Embed the workbook in BASE64: paste into XLSX_BASE64 and set USE_EMBED=true
  -->

  <div class="topbar">
    <label for="typeFilter"><strong>Incident type:</strong></label>
    <select id="typeFilter"><option value="__ALL__">All types</option></select>
    <span class="spacer"></span>
    <button id="reload">Reload</button>
  </div>

  <pre class="status" id="status">Loading workbookâ€¦</pre>

  <script>
    // ======== CONFIGURE YOUR DATA SOURCE HERE ========
    const USE_EMBED = false; // set true to use the embedded base64 below (Option B)

    // Option A: Load from URL (recommended)
    // Place your XLSX next to this file or provide an absolute URL with CORS enabled.
    const XLSX_URL = 'Bridge Incident Case Database  (1).xlsx'; // e.g. './data/incidents.xlsx'

    // Option B: Embedded base64 XLSX (paste your own; a tiny sample sheet is provided)
    const XLSX_BASE64 =
      'UEsDBBQABgAIAJ3Yq1QAAAAAAAAAAAAAAAAUAAAAd29ya2Jvb2sueGxzeG1s7JJNTsMwEIbv/Io' +
      '...' + // <-- replace with your full base64 string
      'AAAUEsBAhQAFAAIAAgAndirVAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAACkgQAAAAB3b3JrYm9v' +
      'ay54bHN4bWwAAQAAAAAAAQAAAFBLBQYAAAAAAQABAEYAAABVAAAAAAA=';
    // ==================================================

    // --- Map ---
    const map = L.map('map', { preferCanvas: true }).setView([31, -99], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const status = document.getElementById('status');
    const typeFilter = document.getElementById('typeFilter');
    const reloadBtn = document.getElementById('reload');

    // If your sheet uses a different column for the incident type, change this:
    const INCIDENT_KEY = 'Incident Type';

    // --- Helpers ---
    function keyLookup(obj, patterns) {
      const keys = Object.keys(obj || {});
      const found = keys.find(k => patterns.some(rx => rx.test(k)));
      return found || null;
    }
    function looksSwapped(lon, lat) { return Math.abs(lon) <= 90 && Math.abs(lat) > 90 && Math.abs(lat) <= 180; }
    function titleCase(s) { return String(s).replace(/\w\S*/g, t => t[0].toUpperCase()+t.slice(1).toLowerCase()); }
    function makePopup(props) {
      if (!props) return '';
      const rows = [];
      const isUrl = v => typeof v === 'string' && /^https?:\/\//i.test(v);
      const domainText = url => { try { return new URL(url).hostname.replace(/^www\./,''); } catch { return url; } };
      for (const [k, rawV] of Object.entries(props)) {
        if (rawV == null) continue;
        let v = String(rawV).trim();
        if (!v || v.toLowerCase() === 'null') continue;
        if (isUrl(v)) v = `<a href="${rawV}" target="_blank" rel="noopener">${domainText(rawV)}</a>`;
        rows.push(`<tr><th style="text-align:left; padding-right:8px;">${k}</th><td>${v}</td></tr>`);
      }
      return `<div style="font:13px/1.3 system-ui, Segoe UI, Roboto, Arial;"><table>${rows.join('')}</table></div>`;
    }

    // PALETTE WITHOUT RED
    const palette = [
      "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#a65628", "#f781bf", "#999999",
      "#66c2a5", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3",
      "#80b1d3", "#bebada"
    ];
    function colorMapFor(types){ const m={}; types.forEach((t,i)=>m[t]=palette[i%palette.length]); return m; }

    // Parse a single "coordinates (lat, lon)" field into {lat, lon}
    function parseCoordsField(val) {
      if (val == null) return null;
      const s = String(val).trim();
      const m = s.match(/-?\d+(?:\.\d+)?/g);
      if (!m || m.length < 2) return null;
      let lat = parseFloat(m[0]), lon = parseFloat(m[1]);
      if (Math.abs(lat) > 90 && Math.abs(lon) <= 90) { const t = lat; lat = lon; lon = t; }
      if (!isFinite(lat) || !isFinite(lon)) return null;
      return { lat, lon };
    }

    // --- XLSX reading helpers ---
    async function readXlsxFromUrl(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`Failed to fetch ${url} (${res.status})`);
      const buf = await res.arrayBuffer();
      const wb = XLSX.read(buf, { type: 'array' });
      if (!wb.SheetNames.length) throw new Error('Workbook has no sheets');
      const sheet = wb.Sheets[wb.SheetNames[0]];
      return XLSX.utils.sheet_to_json(sheet, { defval: '', raw: true });
    }

    function readXlsxFromBase64(b64) {
      // Convert base64 -> Uint8Array for SheetJS
      const bin = atob(b64.replace(/^data:.*;base64,/, ''));
      const len = bin.length;
      const bytes = new Uint8Array(len);
      for (let i=0; i<len; i++) bytes[i] = bin.charCodeAt(i);
      const wb = XLSX.read(bytes, { type: 'array' });
      if (!wb.SheetNames.length) throw new Error('Workbook has no sheets');
      const sheet = wb.Sheets[wb.SheetNames[0]];
      return XLSX.utils.sheet_to_json(sheet, { defval: '', raw: true });
    }

    // ---- INCIDENT TYPE NORMALIZATION + MERGING ----
    const DISPLAY_LABELS = {
      'vehicle collision': 'Vehicle Collision',
      'structural issue': 'Structural Issue'
    };

    function normalizeType(v) {
      if (v == null) return null;
      v = String(v).toLowerCase().replace(/[_-]+/g, ' ').replace(/\s+/g, ' ').trim();
      if (!v) return null;
      if (/ies$/.test(v)) v = v.replace(/ies$/, 'y');
      else if (/(ses|xes|zes|ches|shes)$/.test(v)) v = v.replace(/es$/, '');
      else if (v.endsWith('s') && !v.endsWith('ss')) v = v.slice(0, -1);
      const alias = {
        'vehicle collision': 'vehicle collision',
        'vehicle overload':  'vehicle collision',
        'overloaded truck':  'vehicle collision',
        'truck overload':    'vehicle collision',
        'overload truck':    'vehicle collision',
        'structure failure': 'structural issue',
        'structural failure':'structural issue',
        'hole found in bridge': 'structural issue',
        'hole on bridge':       'structural issue'
      };
      if (alias[v]) v = alias[v];
      return v;
    }

    function displayLabel(norm) {
      return DISPLAY_LABELS[norm] || titleCase(norm);
    }

    // --- plotting state ---
    let currentLayer = null;
    let groupsByType = {};
    let allMarkers = [];

    async function plotFromRows(rows) {
      if (!rows.length) throw new Error('Sheet seems empty.');
      const sample = rows[0] || {};
      const latKey   = keyLookup(sample, [/^lat(i(tude)?)?$/i]);
      const lonKey   = keyLookup(sample, [/^(lon(g(itude)?)?|lng)$/i]);
      const coordKey = keyLookup(sample, [/^coordinates?\s*\(\s*lat\s*,\s*lon\s*\)$/i]);

      if (!((latKey && lonKey) || coordKey)) {
        throw new Error('Could not find latitude/longitude columns or a "coordinates (lat, lon)" column.');
      }

      const features = [];
      for (const r of rows) {
        let lat, lon;
        if (coordKey) {
          const pair = parseCoordsField(r[coordKey]); if (!pair) continue;
          ({ lat, lon } = pair);
        } else {
          lat = parseFloat(r[latKey]); lon = parseFloat(r[lonKey]);
        }
        if (!isFinite(lat) || !isFinite(lon)) continue;
        if (looksSwapped(lon, lat)) { const t = lat; lat = lon; lon = t; }
        features.push({ type:"Feature", properties:r, geometry:{ type:"Point", coordinates:[lon, lat] }});
      }
      if (!features.length) throw new Error('No valid coordinates parsed from sheet.');

      if (currentLayer) { map.removeLayer(currentLayer); currentLayer = null; }
      document.querySelectorAll('.legend').forEach(el => el.remove());
      typeFilter.value = '__ALL__';
      for (let i = typeFilter.options.length - 1; i >= 1; i--) typeFilter.remove(i);
      groupsByType = {};
      allMarkers = [];

      const typeSet = new Set();
      for (const f of features) {
        const norm = normalizeType(f.properties?.[INCIDENT_KEY]);
        if (norm != null) typeSet.add(norm);
      }
      const typeValues = Array.from(typeSet).sort();
      const colors = colorMapFor(typeValues);
      for (const norm of typeValues) {
        const opt = document.createElement('option'); opt.value = norm; opt.textContent = displayLabel(norm);
        typeFilter.appendChild(opt);
        groupsByType[norm] = [];
      }

      for (const f of features) {
        const tNorm = normalizeType(f.properties?.[INCIDENT_KEY]);
        if (tNorm == null) continue;
        const [lon, lat] = f.geometry.coordinates;
        const marker = L.circleMarker([lat, lon], {
          radius: 4,
          fillColor: colors[tNorm] || '#666',
          color: '#333',
          weight: 1,
          opacity: 1,
          fillOpacity: 0.9
        }).bindPopup(makePopup(f.properties));
        groupsByType[tNorm].push(marker);
        allMarkers.push(marker);
      }

      currentLayer = L.featureGroup(allMarkers).addTo(map);
      const b = currentLayer.getBounds(); if (b.isValid()) map.fitBounds(b.pad(0.1));

      const legend = L.control({ position:'topright' });
      legend.onAdd = function() {
        const div = L.DomUtil.create('div','legend');
        const h = document.createElement('div'); h.textContent = 'Incident Type';
        h.style.fontWeight='600'; h.style.marginBottom='6px';
        div.appendChild(h);
        for (const norm of typeValues) {
          const label = displayLabel(norm);
          if (!label) continue;
          const row = document.createElement('div'); row.className='row';
          const sw = document.createElement('span'); sw.className='swatch'; sw.style.background = colors[norm];
          const lab = document.createElement('span'); lab.textContent = label;
          row.appendChild(sw); row.appendChild(lab); div.appendChild(row);
        }
        return div;
      };
      legend.addTo(map);

      status.textContent = `Plotted ${allMarkers.length} points. Types: ${typeValues.length}`;

      typeFilter.onchange = () => {
        if (currentLayer) map.removeLayer(currentLayer);
        let markersToShow = [];
        if (typeFilter.value === '__ALL__') {
          markersToShow = allMarkers;
        } else {
          markersToShow = groupsByType[typeFilter.value] || [];
        }
        currentLayer = L.featureGroup(markersToShow).addTo(map);
        const bb = currentLayer.getBounds(); if (bb.isValid()) map.fitBounds(bb.pad(0.1));
        const label = (typeFilter.value === '__ALL__') ? 'ALL types' : `"${typeFilter.selectedOptions[0].textContent}"`;
        status.textContent = `Showing ${label}. Points: ${markersToShow.length}`;
      };
    }

    // --- bootstrap ---
    async function loadAndPlot() {
      try {
        status.textContent = USE_EMBED
          ? 'Reading embedded workbookâ€¦'
          : `Fetching ${XLSX_URL}â€¦`;

        const rows = USE_EMBED
          ? readXlsxFromBase64(XLSX_BASE64)
          : await readXlsxFromUrl(XLSX_URL);

        await plotFromRows(rows);
      } catch (err) {
        console.error(err);
        status.textContent = `Error: ${err.message}\n\nTips:\nâ€¢ If using a URL, make sure it is same-origin or CORS-enabled.\nâ€¢ Verify the first sheet has either Lat/Lon columns or a "coordinates (lat, lon)" column.`;
      }
    }

    reloadBtn.addEventListener('click', loadAndPlot);
    window.addEventListener('DOMContentLoaded', loadAndPlot);
  </script>
</body>
</html>
